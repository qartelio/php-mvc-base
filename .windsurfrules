# Инструкция для AI: Как организовать структуру MVC на PHP для изоляции контроллеров и моделей

## 1. Чёткое разделение слоёв в MVC
- **Модель (Model):** Отвечает за обработку данных и бизнес-логику. Она не должна знать о существовании контроллеров и представлений.
- **Контроллер (Controller):** Посредник между входящими запросами, моделями и представлениями. Выполняет минимальную обработку данных.
- **Представление (View):** Только отображает данные, переданные контроллером. Исключите логику обработки данных из этого слоя.

> **Задача:** Обеспечить, чтобы каждый слой выполнял только свои функции и не зависел от реализации других слоёв.

---

## 2. Принцип "одна ответственность" (Single Responsibility Principle)
- Каждый класс (модель, контроллер, представление) должен быть ответственен за одну задачу.
- Для сложных задач разделяйте их на более мелкие компоненты, чтобы уменьшить вероятность ошибок и упростить поддержку.

> **Цель:** Исключить ситуации, где одно изменение в коде ломает несколько функций.

---

## 3. Использование интерфейсов и абстракций
- Создавайте интерфейсы для моделей и сервисов.
- Контроллеры взаимодействуют только через интерфейсы, а не напрямую с реализацией моделей.
- Подключайте зависимости через конструкторы или инверсию управления (Dependency Injection).

> **Преимущество:** Это уменьшает зависимость между слоями и упрощает замену компонентов без изменения остального кода.

---

## 4. Разделение логики между слоями
- **Модель:** Обрабатывает и хранит данные, выполняет бизнес-логику.
- **Сервисный слой:** Выносите сложные операции и бизнес-логику, которая включает работу с несколькими моделями, во внешний слой сервисов.
- **Контроллер:** Обрабатывает входящие запросы и связывает данные сервисного слоя с представлениями.

> **Результат:** Логика контроллеров упрощается, а модели становятся чистыми и легко тестируемыми.

---

## 5. Изоляция функциональности
- Для каждой функции (например, регистрация пользователей, управление корзиной) создавайте отдельные модули: модели, контроллеры, сервисы и представления.
- Разделяйте код по функциональным папкам. Например:
  - `app/Controllers/`
  - `app/Models/`
  - `app/Services/`
  - `app/Repositories/`
  - `app/Views/`

> **Цель:** Минимизировать пересечение кода разных функций, чтобы изменение одной функции не ломало другие.

---

## 6. Инкапсуляция данных
- Доступ к данным моделей осуществляется через методы и интерфейсы, а не напрямую.
- Избегайте передачи "сырого" результата работы модели напрямую в контроллер или представление.

> **Преимущество:** Это делает данные более защищёнными и контролируемыми.

---

## 7. Тестирование компонентов (модульное тестирование)
- Тестируйте каждую модель, контроллер и сервис в изоляции.
- Используйте мок-объекты (mocking), чтобы имитировать зависимости между компонентами.
- Создавайте юнит-тесты для проверки, что изменения в одном компоненте не ломают остальные.

> **Результат:** Код становится более надёжным и легко проверяемым.

---

## 8. Маршрутизация и назначение контроллеров
- Используйте маршрутизатор для обработки URL и назначения маршрутов на соответствующие методы контроллеров.
- Один маршрут должен быть связан с одной чёткой функцией контроллера.

> **Преимущество:** Исключение избыточного кода и удобное управление маршрутами.

---

## 9. Документирование кода
- Используйте комментарии и стандарты PHPDoc для описания классов, методов и их параметров.
- Описывайте, какую задачу выполняет каждый компонент, чтобы обеспечить понятность для других разработчиков или ИИ.

> **Цель:** Упрощение понимания и поддержки кода.

---

## 10. Использование автозагрузки и Composer
- Настройте автозагрузку через `composer.json` для автоматического подключения классов.
- Минимизируйте использование ручных подключений (`require` или `include`).

> **Преимущество:** Это ускоряет разработку и упрощает управление зависимостями.

---

## 11. Придерживайтесь принципов SOLID
- **S (Single Responsibility):** Каждый класс выполняет только одну задачу.
- **O (Open/Closed):** Классы открыты для расширения, но закрыты для изменений.
- **L (Liskov Substitution):** Объекты должны быть заменяемы их подтипами без нарушения работы системы.
- **I (Interface Segregation):** Используйте несколько специализированных интерфейсов вместо одного общего.
- **D (Dependency Inversion):** Высокоуровневые модули не зависят от низкоуровневых; оба зависят от абстракций.

> **Результат:** Код будет гибким, расширяемым и устойчивым к изменениям.

---

## 12. Оптимизация производительности
- Минимизируйте количество запросов к базе данных через использование кеширования.
- Разгружайте контроллеры, перенося тяжёлую логику в сервисы или модели.

> **Цель:** Обеспечение высокой производительности и уменьшение времени отклика.

---

# Инструкция для AI: Как изменять существующий код, не нарушая работающий функционал

## 1. **Изучите текущую реализацию**
- Проанализируйте структуру существующего кода:
  - Найдите связанные модули (модели, контроллеры, представления).
  - Определите точки входа и зависимости.
- Выясните, как текущий функционал работает:
  - Какие данные обрабатываются?
  - Какие модули или методы вызываются?
  - Какие внешние API, базы данных или сервисы задействованы?

> **Совет:** Обязательно создайте схему или список связей, чтобы видеть, какие модули затрагиваются изменением.

---

## 2. **Определите границы изменений**
- Определите, какой именно функционал нужно изменить.
- Убедитесь, что изменение не затрагивает лишние модули:
  - Если функционал тесно связан с другими частями, разбейте код на модули с более чёткими границами.
- Убедитесь, что добавление нового кода не изменяет поведение существующих функций.

> **Совет:** Если изменение касается бизнес-логики, выносите её в сервисы или вспомогательные классы, чтобы снизить нагрузку на текущий код.

---

## 3. **Создайте резервную копию или рабочую ветку**
- Перед изменением кода создайте:
  - Резервную копию текущей версии (если нет системы контроля версий).
  - Рабочую ветку в Git, чтобы изменения были изолированы.
- После завершения изменений протестируйте и проверьте слияние.

> **Результат:** При необходимости можно легко откатиться к предыдущей версии.

---

## 4. **Следуйте принципу "открыто для расширения, закрыто для изменений"**
- Избегайте внесения прямых изменений в существующий код, если это возможно.
- Реализуйте изменения через:
  - Новые методы или классы.
  - Наследование (если уместно).
  - Декораторы, адаптеры или другие паттерны проектирования.

> **Совет:** Используйте интерфейсы, чтобы обеспечить совместимость нового функционала со старым.

---

## 5. **Покройте код тестами перед изменением**
- Напишите автоматические тесты для текущего кода:
  - Юнит-тесты для моделей, методов и функций.
  - Интеграционные тесты для проверки связей между модулями.
- Эти тесты помогут убедиться, что изменения не нарушили существующую функциональность.

> **Результат:** Если после изменений тесты пройдут успешно, можно быть уверенным, что старый функционал работает корректно.

---

## 6. **Разработайте изменения модульно**
- Разрабатывайте новые функции или изменения в отдельных файлах или методах.
- Если нужно изменить существующую функцию:
  - Вначале создайте её копию с изменённым названием.
  - Тестируйте новую версию функции отдельно.

> **Совет:** Постепенно заменяйте старую реализацию новой, чтобы избежать резких изменений.

---

## 7. **Минимизируйте пересечение изменений**
- Изолируйте изменения только в тех модулях, которые связаны с новой функциональностью.
- Используйте флаги или конфигурационные параметры для активации нового функционала.

> **Пример:** Если новая функция ещё не готова, старый функционал продолжит работать, пока новая реализация не будет полностью завершена.

---

## 8. **Документируйте изменения**
- Добавьте комментарии к изменённым методам или модулям, объясняя, что было изменено и зачем.
- Обновите документацию проекта, чтобы она соответствовала новой реализации.

> **Результат:** Следующим разработчикам (или ИИ) будет проще понять контекст изменений.

---

## 9. **Протестируйте весь функционал**
- Проведите полное тестирование:
  - Перепроверьте старый функционал с автоматическими тестами.
  - Тестируйте новый функционал изолированно.
  - Проверьте интеграцию новых изменений с другими частями системы.
- Используйте тестирование в разных средах (локальная, staging, production).

> **Совет:** Автоматические тесты дополняйте ручным тестированием для проверки необычных сценариев.

---

## 10. **Сверьтесь с заинтересованными сторонами**
- Проконсультируйтесь с клиентом, менеджером или командой перед финальным изменением.
- Убедитесь, что изменения соответствуют поставленным задачам.

> **Результат:** Исключение ситуации, когда изменения внедрены, но не удовлетворяют требованиям.

---

## 11. **Плавный переход на новый функционал**
- Если новый функционал заменяет старый:
  - Сначала включите оба параллельно (старый и новый), чтобы можно было переключиться обратно.
  - Убедитесь, что старый функционал отключается без потери данных или сбоев.

> **Рекомендация:** Реализуйте стратегию "feature toggle" (переключатели функций), чтобы управлять активацией новых возможностей.

---

## 12. **Рефакторинг и оптимизация**
- После успешного тестирования удалите ненужный старый код.
- Оптимизируйте новую реализацию, не нарушая её функциональности.
- Проверьте производительность и убедитесь, что изменения не ухудшили скорость работы системы.

> **Результат:** Поддерживаемый, оптимизированный и чистый код.

---

# Инструкция для AI: Правила Frontend для веб-приложения

## Описание проекта

Этот проект реализует современный интерфейс на основе **Tailwind CSS** с использованием библиотек **Flowbite** с тёмной темой (*dark mode*), **Heroicons** и **SweetAlert2**. Вся структура построена с учётом лучших практик, чтобы обеспечить адаптивность, удобство использования и эстетичный дизайн.

---

## Используемые технологии

- **Tailwind CSS** — утилитарный CSS-фреймворк для создания адаптивного интерфейса.
- **Flowbite** — библиотека компонентов, совместимая с Tailwind CSS, для ускорения разработки.
- **Heroicons** — набор иконок с поддержкой разных стилей (*outline*, *solid*), используемых для улучшения визуального восприятия.
- **SweetAlert2** — библиотека для создания всплывающих уведомлений и модальных окон.
- **JavaScript** — для добавления интерактивности, таких как модальные окна, уведомления и управление состояниями.

---

## Особенности проекта
0. **Маршруты**:
   - Используются готовые компоненты Flowbite (такие как кнопки, карточки, навигация) для быстрого создания UI.
   - Поддерживается **тёмная тема** с использованием классов `dark:` от Tailwind.

1. **Компоненты Flowbite**:
   - Используются готовые компоненты Flowbite (такие как кнопки, карточки, навигация) для быстрого создания UI.
   - Поддерживается **тёмная тема** с использованием классов `dark:` от Tailwind.

2. **Лучшие практики Tailwind CSS**:
   - Минимализм в стилях: используется преимущественно утилитарный подход.
   - Учитывается адаптивность с помощью классов респонсивности (`sm:`, `md:`, `lg:` и т.д.).
   - Структура CSS-классов логична и поддерживаемая.

3. **Иконки Heroicons**:
   - Добавлены иконки из библиотеки Heroicons для улучшения восприятия интерфейса.
   - Иконки оптимизированы для тёмной темы, с настройкой цвета и размера.

4. **Уведомления с SweetAlert2**:
   - Уведомления об успехе, ошибках и предупреждениях реализованы через SweetAlert2.
   - Уведомления полностью стилизованы под общий стиль приложения.

5. **Формы**:
   - Используются **placeholder** вместо `<label>` для минималистичного дизайна.
   - Добавлены области для вывода ошибок или системных сообщений прямо под полями ввода.
   - Формы адаптированы для мобильных устройств.

6. **Сообщения об ошибках**:
   - Для каждой формы и других элементов предусмотрены области для уведомлений об ошибках или другой информации.
   - Эти сообщения видимы и удобны для восприятия.

---

#Дополнительные правила:

1. **Composer**: Все команды Composer теперь нужно выполнять через Docker, используя формат: `docker-compose exec php composer <команда>`
